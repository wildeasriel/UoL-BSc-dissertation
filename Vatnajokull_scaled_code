var rgiGlobal = ee.FeatureCollection('projects/ee-jmleaglacio/assets/RGI7pt0/RGI7product')


var rgiVatna = rgiGlobal.filter(ee.Filter.bounds(geometry))
print ('RGI Vatnajokull polygons', rgiVatna)
Map.addLayer(rgiVatna.geometry(), null, 'RGI Vatnajokull polygons')



var demVatna = ee.Image("MERIT/DEM/v1_0_3").select('dem').clip(rgiVatna)
Map.addLayer(ee.Terrain.hillshade(demVatna), null, 'MERIT DEM');



var centrelinesVatna = ee.FeatureCollection('projects/ee-jmleaglacio/assets/RGI7pt0/RGI7centerlines')
  .filter(ee.Filter.bounds(geometry))
  .sort('length_m', false)
print ('RGI Vatnajokull centrelines:', centrelinesVatna)

/////////////////////////////
///     CLOUD MASKING     ///
/////////////////////////////

/// > from Robert McNabb, via Davies et al. (2024)
/// > Defines a function which works as a bitmask filter using the QA_pixel quality band to filter out pixels affected by clouds and cloud shadows

function cloudMask(image) {
  var qa = image.select('QA_PIXEL');
  var cloud = qa
    .bitwiseAnd(1 << 1)                                                                                     // dilated clouds
    .or(qa.bitwiseAnd(1 << 2))                                                                              // cirrus
    .or(qa.bitwiseAnd(1 << 3))                                                                              // cloud
    .or(qa.bitwiseAnd(1 << 4));                                                                             // cloud shadow

  return image.updateMask(cloud.not())                                                                      //.updateMask(edge);
}











///////////////////////////////////
/// COMBINED LANDSAT COLLECTION ///
///////////////////////////////////

/// > Loads Landsat 4-9
/// > Filters to the bounds of the shapefile
/// > Remaps relevant bands from Landsats 4-7 to those from Landsats 8-9
/// > Masks cloudy pixels
/// > Does NOT filter out whole cloudy images due to persistently high cloud cover above VatnajÃ¶kull

var landsat4 = ee.ImageCollection("LANDSAT/LT04/C02/T1_L2").filterBounds(rgiVatna)                           // .filterBounds ensures only loading images within rgi shapefile
  .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'QA_PIXEL'],                               // Select bands and reassign to those used in Landsat 8-9
    ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'QA_PIXEL'])
  .map(cloudMask)                                                                                           // Map McNabb's cloud mask function over the collection

var landsat5 = ee.ImageCollection("LANDSAT/LT05/C02/T1_L2").filterBounds(rgiVatna)
  .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'QA_PIXEL'],
    ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'QA_PIXEL'])
  .map(cloudMask)

var landsat7 = ee.ImageCollection("LANDSAT/LE07/C02/T1_L2").filterBounds(rgiVatna)                           // Note shift from TM to ETM
  .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'QA_PIXEL'],
    ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'QA_PIXEL'])
  .map(cloudMask)

var landsat8 = ee.ImageCollection("LANDSAT/LC08/C02/T1_L2").filterBounds(rgiVatna)                           // Note shift from ETM to OLI
  .select(['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'QA_PIXEL'])
  .map(cloudMask)
  
var landsat9 = ee.ImageCollection("LANDSAT/LC09/C02/T1_L2").filterBounds(rgiVatna)
  .select(['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'QA_PIXEL'])
  .map(cloudMask)

var landsat = landsat4
  .merge(landsat5)
  .merge(landsat7)
  .merge(landsat8)
  .merge(landsat9)
  .sort('system:time_start');











///////////////////////////
///         NDSI        ///
///////////////////////////

var landsatNdsiUnmappedNoMask = function(image) {                                                                 // Creates a function which...
  var ndsi = image.expression(                                                                              // For each image in a given collection applies the expression...
    '(green - swir1) / (green + swir1)',                                                                    // Of the NDSI equation...
    {
      green: image.select('SR_B3'),                                                                         // For which these are the bands required...
      swir1: image.select('SR_B6')
    });
    
  return image.addBands(ndsi.rename('NDSI'));                                                     // And this adds NDSI as a band to the image in the collection.
};

var landsatNdsiNoMask = landsat.map(landsatNdsiUnmappedNoMask)

var landsatNdsi = landsatNdsiNoMask.map(function(image) {
  var ndsi = image.select('NDSI');
  var ndsiMask = ndsi.gt(0.38);
  
  return image.updateMask(ndsiMask).clip(rgiVatna)
});










///////////////////////////
///        ALBEDO       ///
///////////////////////////

/// > Calculates albedo using an eq. presented by Liang (2001), via Davies et al. (2024)
/// > Adapted to use USGS scale factors

var scaleFactor = 0.0000275;
var offset = -0.2;

var landsatAlbedoUnmapped = function(image){                                                                  // Creates a function which...
  
  var scaledBands = image.select(['SR_B2', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7'])                               // Rescales the bands in each image in a given collection so albedo can be calculated accurately...
    .multiply(scaleFactor).add(offset);
  
  var albedo = scaledBands.expression(
    '(0.356 * blue) + (0.130 * red) + (0.373 * nir) + (0.085 * swir1) + (0.072 * swir2) - 0.0018',            // Calculates Liang's shortwave albedo equation for each image using the rescaled bands...
    {
      'blue': scaledBands.select('SR_B2'),                                                                    // Defines these as the bands...
      'red': scaledBands.select('SR_B4'),
      'nir': scaledBands.select('SR_B5'),
      'swir1': scaledBands.select('SR_B6'),
      'swir2': scaledBands.select('SR_B7')
    });
  
  return image.addBands(albedo.rename('Albedo'));                                                   // Adds albedo as an image band.
};

var landsatAlbedoNdsi = landsatNdsi.map(landsatAlbedoUnmapped);









///////////////////////////
///     MEAN ALBEDO     ///
///////////////////////////

var addMeanAlbedoMetadata = function(image) {
  var meanAlbedoDict = image.select('Albedo').reduceRegion({
    reducer: ee.Reducer.mean(),
    geometry: rgiVatna,
    scale: 30,
    maxPixels: 1e13
  });
  
  var meanAlbedo = ee.Number(meanAlbedoDict.get('Albedo'));
  return image.set('MEAN_ALBEDO', meanAlbedo);
}

var landsatComplete = landsatAlbedoNdsi.map(addMeanAlbedoMetadata)










///////////////////////////////
/// GLACIER ALBEDO PIPELINE ///
///////////////////////////////

var glacierList = rgiVatna.aggregate_array('rgi_id');

ee.List(glacierList).evaluate(function(clientSideList) {
  
  for (var i = 0; i < clientSideList.length; i++) {
    
    var glacierId = clientSideList[i];
    print('Processing glacier:', glacierId);
    
    var glacier = ee.FeatureCollection(rgiVatna)
      .filter(ee.Filter.eq('rgi_id', glacierId))
      .first();
      
    var glacierGeom = glacier.geometry()
    
// Create monthly albedo mosaics

    var startYear = 1984;
    var endYear = 2024;
    
    var years = ee.List.sequence(startYear, endYear);
    var months = ee.List.sequence(1, 12);
    
    var monthlyMosaicsWithEmptyMosaics = ee.ImageCollection.fromImages(
      years.map(function(y) {
        return months.map(function(m) {
          var start = ee.Date.fromYMD(y, m, 1)
          var end = start.advance(1, 'month');
          
          var mosaic = landsatComplete
            .filterDate(start, end)
            .sort('MEAN_ALBEDO', true)
            .select(['Albedo', 'SR_B4'])
            .mosaic()
            .clip(glacierGeom);
            
          return mosaic.set({
            'YEAR': y,
            'MONTH': m,
            'system:time_start': start.millis()
          });
        });
      }).flatten()
    );
    
    var mosaicsBandCount = monthlyMosaicsWithEmptyMosaics.map(function(img) {
      return img.set('band_count', img.bandNames().size());
    });
    
    var mosaicsNoEmpty = mosaicsBandCount.filter(ee.Filter.gt('band_count', 0));
    
// Calculate mosaic valid area and percentage

    var glacierArea = ee.Number(ee.Feature(glacier).area(0.1).divide(1e6))
    
    var landsatValidPixelMask = function(image) {
      var landsatImageBinary = ee.Image(image).select(['SR_B4']).gte(0);
      var landsatImagePixelArea = ee.Image(landsatImageBinary).multiply(ee.Image.pixelArea());
      
      var landsatArea = ee.Number(
        ee.Dictionary(
          ee.Image(landsatImagePixelArea).reduceRegion({
            reducer: ee.Reducer.sum(),
            scale: 30,
            maxPixels: 1e13,
            geometry: ee.Geometry(glacierGeom)
          })
        ).get('SR_B4')
      );
      
      var landsatAreaKm2 = landsatArea.divide(1e6);
      var landsatCoverPct = ee.Number(landsatAreaKm2).divide(glacierArea).multiply(100);
      
      return image.set({
        'VALID_PIXEL_AREA': landsatAreaKm2,
        'VALID_PIXEL_PERCENTAGE': landsatCoverPct
      });
    };
    
    var mosaicsValidArea = mosaicsNoEmpty.map(landsatValidPixelMask)

// Calculate mean metadata

    var addMeanAlbedoMetadata = function(image) {
      var meanAlbedoDict = image.select('Albedo').reduceRegion({
        reducer: ee.Reducer.mean(),
        geometry: glacierGeom,
        scale: 30,
        maxPixels: 1e13
      });
      
      var meanAlbedo = ee.Number(meanAlbedoDict.get('Albedo'));
      
      return image.set('MEAN_ALBEDO', meanAlbedo)
    };
    
    var mosaicsValidAreaMeanAlbedo = mosaicsValidArea.map(addMeanAlbedoMetadata);

// Accumulation and ablation zone albedo

    var aar58 = ee.Number(
      demVatna.reduceRegion({
        reducer: ee.Reducer.percentile([58]),
        geometry: glacierGeom,
        scale: 30,
        maxPixels: 1e13
      }).get('dem')
    );
    
    var ablationMask = demVatna.lt(aar58);
    var accumulationMask = demVatna.gte(aar58);
    
    var zonalAlbedoMosaicsUnmapped = function(image) {
      var ablationAlbedo = image.select('Albedo').updateMask(ablationMask).reduceRegion({
        reducer: ee.Reducer.mean(),
        geometry: glacierGeom,
        scale: 30,
        maxPixels: 1e13
      });
      
      var ablation = ee.Number(ablationAlbedo.get('Albedo'));
      
      var accumulationAlbedo = image.select('Albedo').updateMask(accumulationMask).reduceRegion({
        reducer: ee.Reducer.mean(),
        geometry: glacierGeom,
        scale: 30,
        maxPixels: 1e13
      });
      
      var accumulation = ee.Number(accumulationAlbedo.get('Albedo'));
      
      return image.set({
        'MEAN_ALBEDO_ABLATION': ablation,
        'MEAN_ALBEDO_ACCUMULATION': accumulation
      });
    };
    
    var zonalAlbedoMosaics = mosaicsValidAreaMeanAlbedo.map(zonalAlbedoMosaicsUnmapped);

// Mosaic data export

    var mosaicStats = zonalAlbedoMosaics.map(function(img) {
      return ee.Feature(null, {
        'RGI_ID': glacierId,
        'YEAR': img.get('YEAR'),
        'MONTH': img.get('MONTH'),
        'TIME_START': img.get('system:time_start'),
        'MEAN_ALBEDO': img.get('MEAN_ALBEDO'),
        'VALID_PIXEL_AREA': img.get('VALID_PIXEL_AREA'),
        'VALID_PIXEL_PERCENTAGE': img.get('VALID_PIXEL_PERCENTAGE'),
        'MEAN_ALBEDO_ABLATION': img.get('MEAN_ALBEDO_ABLATION'),
        'MEAN_ALBEDO_ACCUMULATION': img.get('MEAN_ALBEDO_ACCUMULATION')
      })
    });
    
// Centreline albedo transects

    var centreline = centrelinesVatna.filter(ee.Filter.eq('rgi_g_id', glacierId)).first()
    
    var centrelineLength = ee.Number(ee.Feature(centreline).get('length_m'));
    
    var centrelineSplitDistances = ee.List.sequence(0,centrelineLength,500)
    
    var centrelineCoordsList = ee.List(ee.Feature(centreline)
      .cutLines(centrelineSplitDistances).geometry().coordinates());
      
    var centrelineCoordsListIndex = ee.List.sequence(0,
    ee.Number(ee.List(centrelineCoordsList).size()).subtract(1));
    
    var splitLines = ee.FeatureCollection(ee.List(centrelineCoordsListIndex)
      .map(function(ind){
        var line = ee.Geometry.LineString(ee.List(centrelineCoordsList).get(ind))
        return ee.Feature(line)
          .set('RGI_ID', glacierId,
               'DISTANCE_MIN',centrelineSplitDistances.get(ind),                                          // the highest position of the segment (e.g. if ind=5, distance=2500)
               'DISTANCE_MAX',centrelineSplitDistances.get(ee.Number(ind).add(1)),                        // the lowest position of the segment...
               'DISTANCE_MID',ee.Number(ee.Number(centrelineSplitDistances.get(ind))                      // and the midpoint of the segment
                  .add(ee.Number(centrelineSplitDistances.get(ee.Number(ind).add(1)))))
                  .divide(2))
      }));
    
    var addCentrelineSegmentsAlbedo = function(image) {
      var reduced = image.select('Albedo').reduceRegions({
        collection: splitLines,
        reducer: ee.Reducer.mean(),
        scale: 30,
        //maxPixels: 1e13,
      });
      
    return reduced.map(function(f) {
        return f.set({
          'RGI_ID': glacierId,
          'YEAR': image.get('YEAR'),
          'MONTH': image.get('MONTH'),
          'TIME_START': image.get('system:time_start'),
          'DISTANCE_MIN': f.get('DISTANCE_MIN'),
          'DISTANCE_MAX': f.get('DISTANCE_MAX'),
          'DISTANCE_MID': f.get('DISTANCE_MID'),
          'MEAN': f.get('mean')
        });
      });
    };
    
    var transectStats = zonalAlbedoMosaics.map(addCentrelineSegmentsAlbedo).flatten();

// Export per-glacier data

    Export.table.toDrive({
      collection: mosaicStats,
      description: glacierId + '_MosaicStats',
      folder: 'ST1_mosaics',
      fileFormat: 'CSV'
    });
    
    Export.table.toDrive({
      collection: transectStats,
      description: glacierId + '_TransectStats',
      folder: 'ST1_transects',
      fileFormat: 'CSV'
    });
  }
});








